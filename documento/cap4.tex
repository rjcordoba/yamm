\newcount\piecab \piecab=0
\encabezadop{Equivalencia de {\ccabez \C/} y {\ccabez \c--}}\piecab=1
La demostración de la equivalencia de los dos lenguajes consistirá en mostrar cómo se pude
transformar un programa en \C/ en uno en \c-- que dé el mismo resultado a partir de los mismos
datos. Para explicar cómo se hace la transformación vamos a introducir un nuevo actor, al que
llamaremos el {\it traductor}, que será quien transforme un programa en otro. Análogamente a los
requerimientos que se exigían al {\it ejecutor} de los programas \c--, se ha buscado un método para
traducir programas presuponiendo el mínimo conocimiento al {\it traductor} para que pueda llevar a
cabo su trabajo.

El modo de transformar los programas está basado en considerar los programas en \C/ como un conjunto
de macroinstrucciones, es decir, cadenas de símbolos que pueden ser convertidas en otras cadenas de
manera prefijada. Casi toda la demostración, y la mayor parte de este documento, consiste presentar
las reglas de transformación de unas cadenas en otras. A partir de estas reglas y de unas pocas
directrices simples el {\it traductor} será capaz de transformar un programa en \C/ en uno en \c--
de manera ‘automática’. No todos los programas en \C/ podrán ser traducidos con el método
presentado---la sintaxis completa de \C/ no está contemplada en las reglas---pero el subconjunto de los
programas que pueden serlo es tal que es fácil ver que cualquier programa puede adaptarse a una
forma que permita traducirlo.

\encabezados{Reglas sobre las macroinstrucciones}

Todas las reglas y directrices para transformar programas aparecen en el apéndice D, presentadas
como una ayuda para escribir programas \c-- usando macroinstrucciones. Se empieza por macros para
definir operaciones básicas y se presentan posteriormente macros que usan las anteriores como texto
de sustitución; el objetivo es llegar a macroinstrucciones que se asemejen a construcciones de \C/,
de modo que un programa en \c-- se pueda escribir mediante macros como si fuese en \C/; así, el
trabajo del {\it traductor} sería ir en sentido contrario y desde construcciones de \C/ ir
sustituyendo hasta llegar a un programa \c-- equivalente. Al igual que a la hora de ejecutar un
programa \c--, la traducción de programas en \C/ se hace manejando solamente símbolos, sin necesidad
de saber nada acerca del programa o siquiera del lenguaje.

La manera de presentar la demostración por medio de macros ayuda a entender el lenguaje \c-- y cómo
a partir de las cuatro instrucciones de que consta se pueden ir contruyendo programas para calcular
operaciones conocidas. Por otra parte, el hecho de incluir los números racionales como tipo de dato
que se pueden usar en los programas que se van a traducir complica y alarga mucho la
demostración. No obstante, éste es sólo un caso particular de objetos que se pueden codificar; con
entender cómo se escriben programas que usen números naturales como dato es suficiente para
comprender cómo construir programas en \c-- y que el lenguaje es Turing-\kern.1em completo. Para
esto no es necesario entender todas las macros, vale con entender cómo se traducen algunas,
especialmente las primeras. No debería ser difícil seguir las traducciones del apéndice D. Para no
alagar la explicación, aquí solamente se comentará de forma breve algunas partes.
