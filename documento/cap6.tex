\piecab=0
\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}\piecab=1
Al igual que con las m谩quinas de Turing, la demostraci贸n de la equivalencia de las funciones
recursivas consiste en presentar una funci贸n que act煤a como ejecutor universal de programas \c--.
Esta funci贸n, llamada 芦{\fgabrielen computar}禄, aparece en el ep茅ndice C.

Las funciones recursivas reciben como entrada y dan como resultado n煤meros naturales. Por tanto,
habr谩 que encontrar la manera de codificar los programas, es decir, encontrar una funci贸n {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificaci贸n
como un n煤mero natural de un programa $ \psi $; as铆, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda despu茅s de la ejecuci贸n, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver c贸mo es la funci贸n {\it C}; seguidamente se comentar谩 brevemente la funci贸n
芦{\fgabrielen computar}禄 y para finalizar la secci贸n veremos c贸mo obtener, a partir de 芦{\fgabrielen
computar}禄 y para un programa cualquier {\it P}, una funci贸n recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcular铆a {\it P} con esos datos.
\encabezados{Programas como n煤meros naturales}
Para ver c贸mo representar un programa \c-- como un n煤mero natural para que pueda ser usado por las
funciones recursivas dividiremos la explicaci贸n en dos partes: explicamos primero c贸mo se codifica
el contenido de una posici贸n y vali茅ndonos de esto definiremos despu茅s la funci贸n {\it C} que
buscamos.
\encabezadot{Codificaci贸n de contenido de posiciones}
Para un programa {\it p} en \c-- vamos a definir una funci贸n $ c_p $ sobre las posiciones de {\it p}
tal que dada una posici贸n devuelva la codificaci贸n como n煤mero natural de la instrucci贸n en esa
posici贸n. Definiremos primero una funci贸n $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f()= 0$, esto es, si no hay dato (contenido de una posici贸n vac铆a).

Para instrucciones que tienen un 煤nico s铆mbolo:
\espacioej$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3, $\hskip22pt $ f(\hbox{\fcode1})=4 $.

Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.1ex\hbox{}}, con \nnat:
\espacioej$ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.1ex\hbox{}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos sencillas funciones: una funci贸n $ g $ que dada una posici贸n de un programa
devuelve la instrucci贸n contenida en esa posici贸n, o nada si la posici贸n est谩 vac铆a; y una funci贸n
para un programa {\it p}, $ h_p $, tal que $ h_p(1) $ es la primera posici贸n de {\it p}, y, para
todo \nnat, $ h_p(n+1) $ es la siguiente de la posici贸n $ h_p(n) $ si tal posici贸n existe, y no est谩
definido si la posici贸n no existe. La funci贸n $ c_p $ ser谩 la composici贸n de estas tres funciones:
%% \espacioej $ c_p = f \circ g \circ  h_p$.
\encaje
$ c_p = f \circ g \circ  h_p$.
\finencaje
Poniendo como ejemplo un programa al que llamaremos {\it 唯}\/:
\vskip.23in
\hbox{{\textfont0=\fpies\textfont1=\tenipeq\scriptfont1=\sevenipeq\textfont2=\tensypeq\scriptfont2=\sevenypeq\parskip3pt
\hbox{\hskip.3in\programa{{\inst1{2}}{\inst1{3}}{\inst1{0}}{\inst\estrella1}}}
\hskip.25in\vbox{$ c_\psi(1)=12 $\par$ c_\psi(2)=16 $\par$ c_\psi(3)=4 $\par$ c_\psi(4)=7
$\vskip2pt}}}
\vskip10pt\vskip0in
\encabezadot{Codificaci贸n de programas}
Para llegar hasta la definici贸n de {\it C} que buscamos, antes definimos dos funciones: una funci贸n,
{\it pm}, para todo \nnat\ de la siguiente manera:
\listanormal
$ pm(1)=5 $\par
$ pm(n+1) $ \hskip3pt es el menor primo mayor que \hskip3pt $ pm(n) $
\finlista
y otra funci贸n sobre un programa {\it p}, a la que llamaremos {\it cm}, con el mismo dominio que la
funci贸n {\it c} definida anteriormente, del siguiente modo:
\listanormal
$ cm_p(1)=3^{c(1)} $\par
$ cm_p(n+1)=cm_p(n)\times pm(n)^{c(n+1)} $
\finlista
Definimos por fin la funci贸n {\it C} que buscamos, que da como resultado la codificaci贸n de un
programa {\it P}, como sigue:
\vskip18pt
\hbox{\hskip.48in{\fitems \raise7.4pt\hbox{$ C(P)=cm_p(\alpha) $} \hskip18pt\vbox{\noindent donde $ \alpha\ge n $
para todo $ n $\hskip0pt plus 1fil\break perteneciente al dominio de $ cm_p $.}}}
\vskip18pt
\noindent Llamemos 煤ltima posici贸n de un programa {\it P} a la posici贸n para la que no hay siguiente
posici贸n en {\it P}. Sea {\fmats } el conjunto de los programas tales que la 煤ltima posici贸n est谩
vac铆a y es la siguiente de alguna posici贸n. Es f谩cil ver que cualquier programa en {\fmats } se
puede transformar en uno equivalente a efectos de computaci贸n, est茅 o no en {\fmats }, quitando la
煤ltima posici贸n. Con los programas que no pertenecen a {\fmats } como dominio la funci贸n {\it C} es
biyectiva; por tanto, cualquier programa, o uno equivalente, se puede codificar y decodificar
un铆vocamente.

Vamos a ver un ejemplo de codificaci贸n de un programa. Para ello tomaremos el programa que se us贸 en
搂5 para explicar c贸mo se escribe en una m谩quina de Turing y lo usaremos para ver c贸mo se transforma
en un n煤mero natural que sirva como entrada para la func铆on recursiva del ap茅ndice D. As铆, si
llamamos {\fmats } al programa
\vskip.23in
\hbox{\hskip.3in\programa{{\inst1{1}} = { } 0 1 {\inst\estrella4}}}
\vskip.2in
\noindent el n煤mero que lo representar铆a ser谩:
\encaje
$ C(\hbox{{\fmats }})=3^8 \times 5^2 \times 7^0 \times 11^1 \times 13^4 \times 17^{19} $
\finencaje
La manera de descodificar un n煤mero para obtener el programa que representa se ve en el
funcionamiento de la funci贸n 芦{\fgabrielen computar}禄. Damos a continuaci贸n algunos apuntes sobre su
funcionamiento.

{\font\fgabriele="GabrieleBadAH" at 17pt
\encabezados{Estructura de la funci贸n 芦{\fgabriele computar}禄}}
