\piecab=0
\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}\piecab=1
Al igual que con las máquinas de Turing, la demostración de la equivalencia de las funciones
recursivas consiste en presentar una función que actúa como ejecutor universal de programas \c--.
Esta función, llamada «{\fgabrielen computar}», aparece en el epéndice C.

Las funciones recursivas reciben como entrada y dan como resultado números naturales. Por tanto,
habrá que encontrar la manera de codificar los programas, es decir, encontrar una función {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificación
como un número natural de un programa $ \psi $; así, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda después de la ejecución, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver cómo es la función {\it C}; seguidamente se comentará brevemente la función
«{\fgabrielen computar}» y para finalizar la sección veremos cómo obtener, a partir de «{\fgabrielen
computar}» y para un programa cualquier {\it P}, una función recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcularía {\it P} con esos datos.
\encabezados{Programas como números naturales}
Para ver cómo representar un programa \c-- como un número natural para que pueda ser usado por las
funciones recursivas dividiremos la explicación en dos partes: explicamos primero cómo se codifica
el contenido de una posición y valiéndonos de esto definiremos después la función {\it C} que
buscamos.
\encabezadot{Codificación de contenido de posiciones}
Para un programa {\it p} en \c-- vamos a definir una función $ c_p $ sobre las posiciones de {\it p}
tal que dada una posición devuelva la codificación como número natural de la instrucción en esa
posición. Definiremos primero una función $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f()= 0$, esto es, si no hay dato (contenido de una posición vacía).

Para instrucciones que tienen un único símbolo:
\espacioej$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3, $\hskip22pt $ f(\hbox{\fcode1})=4 $.

Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.0ex\hbox{’}}, con \nnat:
\espacioej$ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.0ex\hbox{’}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos sencillas funciones: una función $ g $ que dada una posición de un programa
devuelve la instrucción contenida en esa posición, o nada si la posición está vacía; y una función
para un programa {\it p}, $ h_p $, tal que $ h_p(1) $ es la primera posición de {\it p}, y, para
todo \nnat, $ h_p(n+1) $ es la siguiente de la posición $ h_p(n) $ si tal posición existe, y no está
definido si la posición no existe. La función $ c_p $ será la composición de estas tres funciones:
%% \espacioej $ c_p = f \circ g \circ  h_p$.
\encaje
$ c_p = f \circ g \circ  h_p$.
\finencaje
Poniendo como ejemplo un programa al que llamaremos {\it Ψ}\/:
\vskip.23in
\hbox{{\textfont0=\fpies\textfont1=\tenipeq\scriptfont1=\sevenipeq\textfont2=\tensypeq\scriptfont2=\sevenypeq\parskip3pt
\hbox{\hskip.3in\programa{{\inst1{2}}{\inst1{3}}{\inst1{0}}{\inst\estrella1}}}
\hskip.25in\vbox{$ c_\psi(1)=12 $\par$ c_\psi(2)=16 $\par$ c_\psi(3)=4 $\par$ c_\psi(4)=7
$\vskip2pt}}}
\vskip10pt\vskip0in
\encabezadot{Codificación de programas}
Para llegar hasta la definición de {\it C} que buscamos, antes definimos dos funciones: una función,
{\it pm}, para todo \nnat\ de la siguiente manera:
\listanormal
$ pm(1)=5 $\par
$ pm(n+1) $ \hskip3pt es el menor primo mayor que \hskip3pt $ pm(n) $
\finlista
y otra función sobre un programa {\it p}, a la que llamaremos {\it cm}, con el mismo dominio que la
función {\it c} definida anteriormente, del siguiente modo:
\listanormal
$ cm_p(1)=3^{c(1)} $\par
$ cm_p(n+1)=cm_p(n)\times pm(n)^{c(n+1)} $
\finlista
Definimos por fin la función {\it C} que buscamos, que da como resultado la codificación de un
programa {\it P}, como sigue:
\vskip18pt
\hbox{\hskip.48in{\fitems \raise7.4pt\hbox{$ C(P)=cm_p(\alpha) $} \hskip18pt\vbox{\noindent donde $ \alpha\ge n $
para todo $ n $\hskip0pt plus 1fil\break perteneciente al dominio de $ cm_p $.}}}
\vskip18pt
\noindent Llamemos última posición de un programa {\it P} a la posición para la que no hay siguiente
posición en {\it P}. Sea {\fmats 𝕌} el conjunto de los programas tales que la última posición está
vacía y es la siguiente de alguna posición. Es fácil ver que cualquier programa en {\fmats 𝕌} se
puede transformar en uno equivalente a efectos de computación, esté o no en {\fmats 𝕌}, quitando la
última posición. Con los programas que no pertenecen a {\fmats 𝕌} como dominio la función {\it C} es
biyectiva; por tanto, cualquier programa, o uno equivalente, se puede codificar y decodificar
unívocamente.

Vamos a ver un ejemplo de codificación de un programa. Para ello tomaremos el programa que se usó en
§5 para explicar cómo se escribe en una máquina de Turing y lo usaremos para ver cómo se transforma
en un número natural que sirva como entrada para la funcíon recursiva del apéndice D. Así, si
llamamos {\fmats ξ} al programa
\vskip.23in
\hbox{\hskip.3in\programa{{\inst1{1}} = { } 0 1 {\inst\estrella4}}}
\vskip.2in
\noindent el número que lo representaría será:
\encaje
$ C(\hbox{{\fmats ξ}})=3^8 \times 5^2 \times 7^0 \times 11^1 \times 13^4 \times 17^{19} $
\finencaje
La manera de descodificar un número para obtener el programa que representa se ve en el
funcionamiento de la función «{\fgabrielen computar}». Damos a continuación algunos apuntes sobre su
funcionamiento.

{\font\fgabrieleg="GabrieleBadAH" at 17pt
\encabezados{Apuntes sobre la función «{\fgabrieleg computar}»}}%
La definición de función recursiva que se usa aquí está basada en las definiciones de funciones
primitivas recursivas que se dan en [2], pag. 219, y en [x], capítulo~6. Concretamente, la función
«{\fgabrielen computar}» y las demás funciones que usa son de uno de los siguientes tipos,
expresados con la notación en [2], donde $ y'=y+1 $\hskip8pt y\hskip8pt $ 1\le i\le n $:
\vskip2pt
\lfunciones
\funespec{$ \hbox{φ}\equis=0 $}
\funespec{$ \hbox{φ}(x)= x+1 $}
\funespec{$ \hbox{φ}\equis= x_i $}
\funespec{\vrule width0pt depth10pt$ \hbox{φ}\equis= \hbox{ψ}(\hbox{χ}_1\equis, ... , \hbox{χ}_m\equis) $}
\funespec{$ \cases{\hbox{\vrule width0pt depth18pt\fmats φ}(0, x_2, ... x_n)=\hbox{\fmats ψ}(x_2, ... ,x_n), \cr
                   \hbox{\fmats φ}(0, x_2, ... x_n)=\hbox{\fmats χ}(y, \hbox{\fmats φ}(0, x_2, ... x_n), (x_2, ... ,x_n))\cr}$}
\vskip4pt\vskip0pt\finlista
Las funciones se muestran en el apéndice D como un programa \c-- escrito con macros, o sea, como un
programa \C/, con lo que es sencillo de entender. Las dos primeras funciones, llamadas «{\fgabrielen
cero}» son del tipo (i); la siguiente función que aparece, «{\fgabrielen S}», es del tipo (ii); las
funciones en las líneas xx--xx, con nombres de la forma «U{\it x\_y}» son del tipo (iii); todas las
demás funciones son de los tipos (iv) o (v). Concretamente, «{\fgabrielen computar}» es del tipo
(iv).

Antes de seguir con el repaso de las funciones conviene introducir el concepto que llamaremos {\it
registro}, relacionado con los programas \c-- y que se maneja durante la computación tal y como se
hace en el apéndice D.
\encabezadot{Señalador y registro}
Imaginemos que el ejecutor de un programa \c-- tiene otras cosas que hacer, y va y viene, alternando
la ejecución de algunas instrucciones del programa con sus otras tareas; o que el programa es muy
largo y hay varios ejecutores que van turnándose en la ejecución del programa. Esto se podría hacer
manteniendo un señalador que apunte a la próxima instrucción que será ejecutada, del mismo modo que
se usa un marcapáginas en un libro. Asi se podrá dejar y retomar la tarea de ejecutar el programa a
capricho. Al conjunto de programa y el señalador es a lo que llamamos {\it registro}.

Durante la computación con «{\fgabrielen computar}» se trabaja con la codificación de registros. Al
principio de la ejecución se obtiene un registro a partir de la codificación del programa, con el
señalador en la primera posición; según se van ejecutando instrucciones se obtienen las
codificaciones con el señalador donde corresponda. La codificación de un registro ρ para un programa
{\it P} es como sigue:

Si {\it P} es un programa y $\hbox{υ}=\hbox{C}(P)$ es la codificación de {\it P} como número
natural, la codificación del registro ρ a partir de υ es como sigue:
\listanormal
Si $\hbox{υ}=\hbox{C}(\hbox{{\it P}})$ \ es la codificación de {\it P}, entonces \ $ \hbox{ρ}=2\times\hbox{υ} $ \
es la codificación del registro con el señalador apuntando a la primera posición de {\it P}.

Si μ es la codificación de un registro con el señalizador σ apuntando a la posición ψ, entonces
\ $ \hbox{ρ}=2\times\hbox{μ} $ \ es la codificación del registro con el señalizador apuntando a la
siguiente posición de σ en {\it P}.
\finlista
\encabezadot{Apuntes II}
Continuamos haciendo un repaso a las funciones recursivas del apéndice D.
