\piecab=0
\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}\piecab=1
Al igual que con las máquinas de Turing, la demostración de la equivalencia de las funciones
recursivas consiste en presentar una función que actúa como ejecutor universal de programas \c--.
Esta función, llamada «{\fgabrielen computar}», aparece en el epéndice C.

Las funciones recursivas reciben como entrada y dan como resultado números naturales. Por tanto,
habrá que encontrar la manera de codificar los programas, es decir, encontrar una función {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificación
como un número natural de un programa $ \psi $; así, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda después de la ejecución, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver cómo es la función {\it C}; seguidamente se comentará brevemente la función
«{\fgabrielen computar}» y para finalizar la sección veremos cómo obtener, a partir de «{\fgabrielen
computar}» y para un programa cualquier {\it P}, una función recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcularía {\it P} con esos datos.
\encabezados{Codificación de programas}
Para ver cómo representar un programa \c-- como un número natural para que pueda ser usado por las
funciones recursivas, dividiremos la explicación en dos partes: explicamos primero cómo se codifica
el contenido de una posición y valiéndonos de esto definiremos después la función {\it C} que
buscamos.
\encabezadot{Codificación de contenido de posiciones}
Para un programa {\it P} de \c-- vamos a definir una función $ c_P $ sobre las
posiciones de {\it P} tal que dada una posición devuelva la codificación de la instrucción en esa
posición. Definiremos primero una función $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f()= 0$, esto es, si no hay dato (contenido de una posición vacía).\par
Para instrucciones que tienen un único símbolo:\pseudopar
\vbox to 18pt{} \hskip34pt$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3 $\hskip22pt $ f(\hbox{\fcode1})=4 $.\par
Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.1ex\hbox{’}}:\pseudopar
\vbox to 18pt{} \hskip34pt $ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.1ex\hbox{’}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos nuevas funciones: una función $ g $ que dada una posición de un programa
devuelve la instrucción contenida en esa posición, o nada si la posición está vacía, y una función
para un programa {\it P}, $ h_P $, sobre los números naturales, tal que $ h_P(1) $ es la
primera posición de {\it P} y para todo $ n $, $ h_P(n+1) $ es la siguiente posición en {\it P}
de la posición $ n $ si en {\it P} existe la posición siguiente a $ n $ existe y no está definido si
la posición no existe.
