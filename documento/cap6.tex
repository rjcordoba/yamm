\piecab=0
\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}\piecab=1
Al igual que con las máquinas de Turing, la demostración de la equivalencia de las funciones
recursivas consiste en presentar una función que actúa como ejecutor universal de programas \c--.
Esta función, llamada «{\fgabrielen computar}», aparece en el epéndice C.

Las funciones recursivas reciben como entrada y dan como resultado números naturales. Por tanto,
habrá que encontrar la manera de codificar los programas, es decir, encontrar una función {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificación
como un número natural de un programa $ \psi $; así, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda después de la ejecución, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver cómo es la función {\it C}; seguidamente se comentará brevemente la función
«{\fgabrielen computar}» y para finalizar la sección veremos cómo obtener, a partir de «{\fgabrielen
computar}» y para un programa cualquier {\it P}, una función recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcularía {\it P} con esos datos.
\encabezados{Programas como números naturales}
Para ver cómo representar un programa \c-- como un número natural para que pueda ser usado por las
funciones recursivas dividiremos la explicación en dos partes: explicamos primero cómo se codifica
el contenido de una posición y valiéndonos de esto definiremos después la función {\it C} que
buscamos.
\encabezadot{Codificación de contenido de posiciones}
Para un programa {\it p} en \c-- vamos a definir una función $ c_p $ sobre las posiciones de {\it p}
tal que dada una posición devuelva la codificación como número natural de la instrucción en esa
posición. Definiremos primero una función $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f()= 0$, esto es, si no hay dato (contenido de una posición vacía).

Para instrucciones que tienen un único símbolo:
\espacioej$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3, $\hskip22pt $ f(\hbox{\fcode1})=4 $.

Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.1ex\hbox{’}}, con \nnat:
\espacioej$ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.1ex\hbox{’}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos sencillas funciones: una función $ g $ que dada una posición de un programa
devuelve la instrucción contenida en esa posición, o nada si la posición está vacía; y una función
para un programa {\it p}, $ h_p $, tal que $ h_p(1) $ es la primera posición de {\it p}, y, para
todo \nnat, $ h_p(n+1) $ es la siguiente de la posición $ h_p(n) $ si tal posición existe, y no está
definido si la posición no existe. La función $ c_p $ será la composición de estas tres funciones:
%% \espacioej $ c_p = f \circ g \circ  h_p$.
\encaje
$ c_p = f \circ g \circ  h_p$.
\finencaje
Poniendo como ejemplo un programa al que llamaremos {\it Ψ}\/:
\vskip.23in
\hbox{{\textfont0=\fpies\textfont1=\tenipeq\scriptfont1=\sevenipeq\textfont2=\tensypeq\scriptfont2=\sevenypeq\parskip3pt
\hbox{\hskip.3in\programa{{\inst1{2}}{\inst1{3}}{\inst1{0}}{\inst\estrella1}}}
\hskip.25in\vbox{$ c_\psi(1)=12 $\par$ c_\psi(2)=16 $\par$ c_\psi(3)=4 $\par$ c_\psi(4)=7
$\vskip2pt}}}
\vskip10pt\vskip0in
\encabezadot{Codificación de programas}
Para llegar hasta la definición de {\it C} que buscamos, antes definimos dos funciones: una función,
{\it pm}, para todo \nnat\ de la siguiente manera:
\listanormal
$ pm(1)=5 $\par
$ pm(n+1) $ \hskip3pt es el menor primo mayor que \hskip3pt $ pm(n) $
\finlista
y otra función sobre un programa {\it p}, a la que llamaremos {\it cm}, con el mismo dominio que la
función {\it c} definida anteriormente, del siguiente modo:
\listanormal
$ cm_p(1)=3^{c(1)} $\par
$ cm_p(n+1)=cm_p(n)\times pm(n)^{c(n+1)} $
\finlista
Definimos por fin la función {\it C} que buscamos, que da como resultado la codificación de un
programa {\it P}, como sigue:
\vskip18pt
\hbox{\hskip.48in{\fitems \raise7.4pt\hbox{$ C(P)=cm_p(\alpha) $} \hskip18pt\vbox{\noindent donde $ \alpha\ge n $
para todo $ n $\hskip0pt plus 1fil\break perteneciente al dominio de $ cm_p $.}}}
\vskip18pt
\noindent Llamemos última posición de un programa {\it P} a la posición para la que no hay siguiente
posición en {\it P}. Sea {\fmats 𝕌} el conjunto de los programas tales que la última posición está
vacía y es la siguiente de alguna posición. Es fácil ver que cualquier programa en {\fmats 𝕌} se
puede transformar en uno equivalente a efectos de computación, esté o no en {\fmats 𝕌}, quitando la
última posición. Con los programas que no pertenecen a {\fmats 𝕌} como dominio la función {\it C} es
biyectiva; por tanto, cualquier programa, o uno equivalente, se puede codificar y decodificar
unívocamente.

Vamos a ver un ejemplo de codificación de un programa. Para ello tomaremos el programa que se usó en
§5 para explicar cómo se escribe en una máquina de Turing y lo usaremos para ver cómo se transforma
en un número natural que sirva como entrada para la funcíon recursiva del apéndice D. Así, si
llamamos {\fmats 𝝎} al programa
\vskip.23in
\hbox{\hskip.3in\programa{{\inst1{1}} = { } 0 1 {\inst\estrella4}}}
\vskip.2in
\noindent el número que lo representaría será:
\encaje
$ C(\hbox{{\fmats 𝝎}})=3^8 \times 5^2 \times 7^0 \times 11^1 \times 13^4 \times 17^{19} $
\finencaje
La manera de descodificar un número para obtener el programa que representa se ve en el
funcionamiento de la función «{\fgabrielen computar}». Damos a continuación algunos apuntes sobre su
funcionamiento.

{\font\fgabriele="GabrieleBadAH" at 17pt
\encabezados{Estructura de la función «{\fgabriele computar}»}}
