\piecab=0
\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}\piecab=1
Al igual que con las mÃ¡quinas de Turing, la demostraciÃ³n de la equivalencia de las funciones
recursivas consiste en presentar una funciÃ³n que actÃºa como ejecutor universal de programas \c--.
Esta funciÃ³n, llamada Â«{\fgabrielen computar}Â», aparece en el epÃ©ndice C.

Las funciones recursivas reciben como entrada y dan como resultado nÃºmeros naturales. Por tanto,
habrÃ¡ que encontrar la manera de codificar los programas, es decir, encontrar una funciÃ³n {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificaciÃ³n
como un nÃºmero natural de un programa $ \psi $; asÃ­, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda despuÃ©s de la ejecuciÃ³n, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver cÃ³mo es la funciÃ³n {\it C}; seguidamente se comentarÃ¡ brevemente la funciÃ³n
Â«{\fgabrielen computar}Â» y para finalizar la secciÃ³n veremos cÃ³mo obtener, a partir de Â«{\fgabrielen
computar}Â» y para un programa cualquier {\it P}, una funciÃ³n recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcularÃ­a {\it P} con esos datos.
\encabezados{Programas como nÃºmeros naturales}
Para ver cÃ³mo representar un programa \c-- como un nÃºmero natural para que pueda ser usado por las
funciones recursivas dividiremos la explicaciÃ³n en dos partes: explicamos primero cÃ³mo se codifica
el contenido de una posiciÃ³n y valiÃ©ndonos de esto definiremos despuÃ©s la funciÃ³n {\it C} que
buscamos.
\encabezadot{CodificaciÃ³n de contenido de posiciones}
Para un programa {\it p} en \c-- vamos a definir una funciÃ³n $ c_p $ sobre las posiciones de {\it p}
tal que dada una posiciÃ³n devuelva la codificaciÃ³n como nÃºmero natural del contenido de esa
posiciÃ³n. Definiremos primero una funciÃ³n $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f(\kernpeq)= 0$, esto es, si no hay dato (contenido de una posiciÃ³n vacÃ­a).

Para instrucciones que tienen un Ãºnico sÃ­mbolo:
\espacioej$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3, $\hskip22pt $ f(\hbox{\fcode1})=4 $.

Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.0ex\hbox{â€™}}, con \nnat:
\espacioej$ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.0ex\hbox{â€™}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos sencillas funciones: una funciÃ³n $ g $ que dada una posiciÃ³n de un programa
devuelve la instrucciÃ³n contenida en esa posiciÃ³n, o nada si la posiciÃ³n estÃ¡ vacÃ­a; y una funciÃ³n
para un programa {\it p}, $ h_p $, tal que $ h_p(1) $ es la primera posiciÃ³n de {\it p}, y, para
todo \nnat, $ h_p(n+1) $ es la siguiente de la posiciÃ³n $ h_p(n) $ si tal posiciÃ³n existe, y no estÃ¡
definido si la posiciÃ³n no existe. La funciÃ³n $ c_p $ serÃ¡ la composiciÃ³n de estas tres funciones:
%% \espacioej $ c_p = f \circ g \circ  h_p$.
\encaje
$ c_p = f \circ g \circ  h_p$.
\finencaje
Poniendo como ejemplo un programa al que llamaremos {\it Î¨}\/:
\vskip.23in
\hbox{{\textfont0=\fpies\textfont1=\tenipeq\scriptfont1=\sevenipeq\textfont2=\tensypeq\scriptfont2=\sevenypeq\parskip3pt
\hbox{\hskip.3in\programa{{\inst1{2}}{\inst1{3}}{\inst1{0}}{\inst\estrella1}}}
\hskip.25in\vbox{$ c_\psi(1)=12 $\par$ c_\psi(2)=16 $\par$ c_\psi(3)=4 $\par$ c_\psi(4)=7
$\vskip2pt}}}
\vskip10pt\vskip0in
\encabezadot{CodificaciÃ³n de programas}
Para llegar hasta la definiciÃ³n de {\it C} que buscamos, antes definimos dos funciones: una funciÃ³n,
{\it pm}, para todo \nnat\ de la siguiente manera:
\listanormal
$ pm(1)=5 $\par
$ pm(n+1) $ \hskip3pt es el menor primo mayor que \hskip3pt $ pm(n) $
\finlista
y otra funciÃ³n sobre un programa {\it p}, a la que llamaremos {\it cm}, con el mismo dominio que la
funciÃ³n {\it c} definida anteriormente, del siguiente modo:
\listanormal
$ cm_p(1)=3^{c(1)} $\par
$ cm_p(n+1)=cm_p(n)\times pm(n)^{c(n+1)} $
\finlista
Definimos por fin la funciÃ³n {\it C} que buscamos, que da como resultado la codificaciÃ³n de un
programa {\it P}, como sigue:
\vskip18pt
\hbox{\hskip.48in{\fitems \raise7.4pt\hbox{$ C(P)=cm_p(\alpha) $} \hskip18pt\vbox{\noindent donde $ \alpha\ge n $
para todo $ n $\hskip0pt plus 1fil\break perteneciente al dominio de $ cm_p $.}}}
\vskip18pt
\noindent Llamemos Ãºltima posiciÃ³n de un programa {\it P} a la posiciÃ³n para la que no hay siguiente
posiciÃ³n en {\it P}. Sea {\fmats ğ•Œ} el conjunto de los programas tales que la Ãºltima posiciÃ³n estÃ¡
vacÃ­a y es la siguiente de alguna posiciÃ³n. Es fÃ¡cil ver que cualquier programa en {\fmats ğ•Œ} se
puede transformar en uno equivalente a efectos de computaciÃ³n, estÃ© o no en {\fmats ğ•Œ}, quitando la
Ãºltima posiciÃ³n. Con los programas que no pertenecen a {\fmats ğ•Œ} como dominio la funciÃ³n {\it C} es
biyectiva; por tanto, cualquier programa, o uno equivalente, se puede codificar y decodificar
unÃ­vocamente.

Vamos a ver un ejemplo de codificaciÃ³n de un programa. Para ello tomaremos de nuevo el programa que
se usÃ³ en Â§5 para explicar cÃ³mo se escribe en una mÃ¡quina de Turing y lo usaremos otra vez de
ejemplo para ver cÃ³mo se transforma en un nÃºmero natural que sirva como entrada para la funcÃ­on
recursiva del apÃ©ndice D. AsÃ­, si llamamos {\fmats Î¾} al programa
\vskip.23in
\hbox{\hskip.3in\programa{{\inst1{1}} = { } 0 1 {\inst\estrella4}}}
\vskip.2in
\noindent el nÃºmero que lo representarÃ­a serÃ¡:
\encaje
$ C(\hbox{{\fmats Î¾}})=3^8 \times 5^2 \times 7^0 \times 11^1 \times 13^4 \times 17^{19} $
\finencaje
La manera de descodificar un nÃºmero para obtener el programa que representa se ve en el
funcionamiento de la funciÃ³n Â«{\fgabrielen computar}Â». Damos a continuaciÃ³n algunos apuntes sobre su
funcionamiento.

{\font\fgabrieleg="GabrieleBadAH" at 17pt
\encabezados{Apuntes sobre la funciÃ³n Â«{\fgabrieleg computar}Â»}}%
La definiciÃ³n de funciÃ³n recursiva que se usa aquÃ­ estÃ¡ basada en las definiciones de funciones
primitivas recursivas que se dan en [2], pag. 219, y en [x], capÃ­tulo~6. Concretamente, la funciÃ³n
Â«{\fgabrielen computar}Â» y las demÃ¡s funciones que usa son de uno de los siguientes tipos,
expresados con la notaciÃ³n en [2], donde $ y'=y+1 $\hskip8pt y\hskip8pt $ 1\le i\le n $:
\vskip2pt
\lfunciones
\funespec{$ \hbox{Ï†}\equis=0 $}
\funespec{$ \hbox{Ï†}(x)= x+1 $}
\funespec{$ \hbox{Ï†}\equis= x_i $}
\funespec{\vrule width0pt depth10pt$ \hbox{Ï†}\equis= \hbox{Ïˆ}(\hbox{Ï‡}_1\equis, ... , \hbox{Ï‡}_m\equis) $}
\funespec{$ \cases{\hbox{\vrule width0pt depth18pt\fmats Ï†}(0, x_2, ... x_n)=\hbox{Ïˆ}(x_2, ... ,x_n), \cr
                   \hbox{\fmats Ï†}(y', x_2, ... x_n)=\hbox{\fmats Ï‡}(y, \hbox{\fmats Ï†}(y, x_2, ... x_n), x_2, ... ,x_n)\cr}$}
\vskip4pt\vskip0pt\finlista
Las dos primeras funciones en el apÃ©ndice D, llamadas Â«{\fgabrielen cero}Â», son del tipo (i); la
siguiente funciÃ³n que aparece, Â«{\fgabrielen S}Â», es del tipo (ii); las funciones en las lÃ­neas
xx--xx, con nombres de la forma Â«U{\it x\_y}Â» son del tipo (iii); todas las demÃ¡s funciones son de
los tipos (iv) o (v). Concretamente, Â«{\fgabrielen computar}Â» es del tipo (iv).

Las funciones anteriores y el resto se muestran como parte de un programa \c-- escrito con macros, o
sea, en \C/, con lo que son sencillas de entender y no requieren mucha explicaciÃ³n. Veremos por
encima algunas de las funciones y cÃ³mo se hace la computaciÃ³n. Pero antes de seguir con el repaso de
las funciones conviene introducir el concepto que llamaremos {\it registro}, relacionado con los
programas \c-- y que se maneja durante la computaciÃ³n.
\encabezadot{SeÃ±alador y registro}
Imaginemos que el ejecutor de un programa \c-- tiene otras cosas que hacer, y va y viene, alternando
la ejecuciÃ³n de algunas instrucciones del programa con sus otras tareas; o que el programa es muy
largo y hay varios ejecutores que van turnÃ¡ndose en la ejecuciÃ³n del programa. Esto se podrÃ­a hacer
manteniendo un seÃ±alador que apunte a la prÃ³xima instrucciÃ³n que serÃ¡ ejecutada, del mismo modo que
se usa un marcapÃ¡ginas en un libro. Asi se podrÃ¡ dejar y retomar la tarea de ejecutar el programa a
capricho. Al conjunto de programa y el seÃ±alador es a lo que llamamos {\it registro}.

Durante la computaciÃ³n con Â«{\fgabrielen computar}Â» se trabaja con la codificaciÃ³n de registros. Al
principio de la ejecuciÃ³n se obtiene un registro a partir de la codificaciÃ³n del programa, con el
seÃ±alador en la primera posiciÃ³n; segÃºn se van ejecutando instrucciones se obtienen las
codificaciones con el seÃ±alador donde corresponda. La codificaciÃ³n de un registro Ï para un programa
{\it P} es como sigue:

Si {\it P} es un programa y $\hbox{Ï…}=\hbox{C}(P)$ es la codificaciÃ³n de {\it P} como nÃºmero
natural, la codificaciÃ³n del registro Ï a partir de Ï… es como sigue:
\listanormal
Si $\hbox{Ï…}=\hbox{C}(\hbox{{\it P}})$ \ es la codificaciÃ³n de {\it P}, entonces \ $ \hbox{Ï}=2\times\hbox{Ï…} $ \
es la codificaciÃ³n del registro con el seÃ±alador apuntando a la primera posiciÃ³n de {\it P}.

Si Î¼ es la codificaciÃ³n de un registro con el seÃ±alizador apuntando a la posiciÃ³n Ïˆ, entonces \
$ \hbox{Ï}=2\times\hbox{Î¼} $ \ es la codificaciÃ³n del registro con el seÃ±alizador apuntando a la
siguiente posiciÃ³n de Ïˆ en {\it P}.
\finlista
Una vez vistos estos conceptos y cÃ³mo se codifican, vamos a ver cÃ³mo se usan en las funciones
recursivas cuando ejecutan un programa \c--, siguiendo con el repaso del apÃ©ndice D.
\encabezadot{Apuntes (continuaciÃ³n)}
Las funciones entre las lÃ­neas xx y xxx devuelven las constantes necesarias en otras funciones;
seguidamente hay funciones que realizan operaciones aritmÃ©ticas y relacionales y basadas en ellas
otras funciones que resuelven problemas mÃ¡s especÃ­ficos y que serÃ¡n necesarias para definir
funciones que aparecen mÃ¡s adelante. Los comentarios que aparecen en el cÃ³digo explican lo que
hacen.

La funciÃ³n Â«{\fgabrielen computar}Â» recibe el programa y lo pasa, junto con la constante 2, a la
funciÃ³n Â«{\fgabrielen computar\_aux}Â», para que Ã©sta multiplique, creando el registro con el
seÃ±alador apuntando a la primera posiciÃ³n. La funciÃ³n Â«{\fgabrielen evaluar}Â» recibe el registro
junto con la constante 1. Esta funciÃ³n en la que empieza la interpretaciÃ³n de la posiciÃ³n a la que
apunte el seÃ±alador. El parÃ¡metro Â«{\fgabrielen X1}Â» indica si la Ãºltima vez que se interpretÃ³ una
posiciÃ³n Ã©sta estaba vacÃ­a o si hay que seguir con la ejecuciÃ³n del programa. Si se llama con 0 la
ejecuciÃ³n se detendrÃ­a y se devolverÃ­a el programa ejecutado.Â«{\fgabrielen computar\_aux}Â» llama a
Â«{\fgabrielen evaluar}Â» con argumento 1, ya que estamos al principio de la evaluaciÃ³n del programa y
esta Ãºltima llama a Â«{\fgabrielen ejecutar}Â», que interpretarÃ¡ la posiciÃ³n que indica el seÃ±alador.

Desde Â«{\fgabrielen ejecutar}Â», a partir del registro se saca el contenido de la posiciÃ³n a la que
apunta el seÃ±alador y de Ã©ste la instrucciÃ³n si la hubiera. La funciÃ³n Â«{\fgabrielen
eval\_registro}Â» intenta ejecutar los 4 tipos de instrucciones o nada si la posiciÃ³n a interpretar
estÃ¡ vacÃ­a. Cada una de las funciones que empieza por Â«{\fgabrielen eval\_}Â» recibe como primer
parÃ¡metro el tipo de instrucciÃ³n qeu hay que ejecutar o si la posiciÃ³n estÃ¡ vacÃ­a; cada una de las
funciones modificarÃ¡ y devolverÃ¡ el registro segÃºn reciba el tipo de instrucciÃ³n que puede ejecutar
o devolverÃ¡ 0 en caso contrario. Por ejemplo, si el primer parÃ¡metro con el que se llama a la
funciÃ³n Â«{\fgabrielen computar}Â» indica que la intrucciÃ³n a ejecutar es Â«marcarÂ», pondrÃ¡ una marca
en la posiciÃ³n referida por la instrucciÃ³n, avanzarÃ¡ el seÃ±alador una posiciÃ³n y devolverÃ¡ el
registro asÃ­ modificado; si la instrucciÃ³n es otra, devolverÃ¡ 0 en vez de el registro. La funciÃ³n
Â«{\fgabrielen eval\_registro}Â» devuelve finalmente la suma de todos los resultados; sÃ³lo uno serÃ¡
distinto de 0, con lo que Ã©ste serÃ¡ el resultado global. La funciÃ³n Â«{\fgabrielen ejec3}Â» recibe
este valor y llama a Â«{\fgabrielen hay\_inst}Â» para comprobar si la posiciÃ³n estaba vacÃ­a, guardando
este valor en Â«{\fgabrielen V1}Â», que serÃ¡ 0 o 1; con este valor y el registro despuÃ©s de
interpretar la posiciÃ³n adecuada, vuelve a empezar el ciclo llamando a Â«{\fgabrielen evaluar}Â».

Casi todas las demÃ¡s funciones tienen que ver con el descodificado y codificado de intrucciÃ³n,
posiciones, seÃ±alador..., y con la ejecuciÃ³n de las distintas instrucciones. Es mÃ¡s fÃ¡cil seguirlo
con el cÃ³digo y los comentarios que con una explicaciÃ³n.

\encabezados{Sin programa, solamente datos de entrada}
Vamos a ver cÃ³mo construir una funciÃ³n que reciba los datos de entrada que recibirÃ­a un programa
{\it P} en \c-- y devuelva lo mismo que devolverÃ­a la funciÃ³n Â«{\fgabrielen computar}Â» cuando
ejecuta {\it P}. Esta funciÃ³n lo Ãºnico que tendrÃ¡ que hacer es â€˜prepararâ€™ un programa a partir de
los datos de entrada y de {\it P} y pasarlo como argumento a Â«{\fgabrielen computar}Â» para que lo
ejecute. Al igual que se hizo en la explicaciÃ³n para las mÃ¡quinas de Turing, vamos a suponer que los
datos de entrada para {\it P} se colocarÃ­an en las primeras posiciones donde se guardan las
variables o que se modifica {\it P} para que sea asÃ­. Para que la explicaciÃ³n sea mÃ¡s corta
supondremos tambiÃ©n que el programa {\it P} recibe solamente un dato de entrada. El caso para mÃ¡s de
un dato de entrada es algo mÃ¡s largo pero el proceso es casi igual.

Para que la funciÃ³n que buscamos, a la que llamaremos Â«{\fgabrielen precomputar}Â», ejecute un
programa a partir de los datos de entrada, este programa tiene que ser conocido al construir la
funciÃ³n, y por tanto serÃ¡n conocidos tambiÃ©n su codificaciÃ³n y el mayor nÃºmero primo que se ha
usado para la codificaciÃ³n; sean Ã©stos {\it n} y {\it p} respectivamente. La funciÃ³n serÃ­a:

\font\fgabrielen="GabrieleBadAH" at 11pt
\cachosrec
function precomputar(var X1)\Uchar123
~~~var V1 = preparar(X1);
~~~return computar(V1);
\Uchar125
\fincachos
La funciÃ³n preparar usarÃ¡ el dato de entrada y la codificaciÃ³n {\it n}, que es una constante, para
devolver la codificaciÃ³n del programa que necesitamos. La funciÃ³n serÃ¡:
\cachosrec
function preparar(var X1)\Uchar123
~~~var V1 = programa(X1);
~~~var V2 = entrada(X1);
~~~return mult(V1, V2);
\Uchar125
\fincachos
La funciÃ³n Â«{\fgabrielen programa}Â» usarÃ¡ Â«{\fgabrielen cero}Â» y luego Â«{\fgabrielen S}Â» las veces
que haga falta para devolver la constante que representa {\it n}. La funciÃ³n Â«{\fgabrielen entrada}Â»
devolverÃ¡ $ p^\theta $, donde {\it Î¸\/} es la codificaciÃ³n del contenido de lo que serÃ­a la posiciÃ³n
siguiente a la Ãºltima posiciÃ³n del programa {\it P} con el dato de entrada en ella. Con la
multiplicaciÃ³n que se lleva a cabo en Â«{\fgabrielen mult}Â» se obtiene la codificaciÃ³n del programa
que queremos. La funciÃ³n Â«{\fgabrielen entrada}Â» serÃ­a  de la siguiente manera:
\cachosrec
function entrada(var X1)\Uchar123
~~~var V1 = cod\_instrucciÃ³n(X1);
~~~var V2 = primo(X1);
~~~var V3 = uno(X1);
~~~return mult\_veces(V1, V2, V3);
\Uchar125
\fincachos
La funciÃ³n Â«{\fgabrielen primo}Â» devolverÃ¡ como constante el nÃºmero primo {\it p} mencionado
anteriormente, de manera anÃ¡loga a se hace en {\fgabrielen programa}. Â«{\fgabrielen
cod\_instrucciÃ³n}Â» devuelve el {\it Î¸\/} visto antes, que serÃ¡ igual que la codificaciÃ³n del
contenido de una posiciÃ³n con una instrucciÃ³n Â«{\it marcar}Â» con la posiciÃ³n referida igual al dato
de entrada. Las funciones Â«{\fgabrielen uno}Â» y Â«{\fgabrielen mult\_veces}Â» aparecen en el apÃ©ndice
D.  La funciÃ³n Â«{\fgabrielen cod\_instrucciÃ³n}Â» serÃ­a:
\cachosrec
function cod\_instrucciÃ³n(var X1)\Uchar123
~~~var V1 = cuatro(X1);
~~~var V2 = U1\_1(X1);
~~~return mult(V1, V2);
\Uchar125
\fincachos
Las funciones Â«{\fgabrielen U1\_1}Â» y Â«{\fgabrielen mult}Â» aparecen en el apÃ©ndice D. La funciÃ³n
Â«{\fgabrielen cuatro}Â» con un sÃ³lo parÃ¡metro no aparece pero a partir de las que aparecen es fÃ¡cil
ver cÃ³mo construirla para que devuelva la constante 4.

