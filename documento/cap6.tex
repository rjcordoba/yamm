\piecab=0
\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}\piecab=1
Al igual que con las m谩quinas de Turing, la demostraci贸n de la equivalencia de las funciones
recursivas consiste en presentar una funci贸n que act煤a como ejecutor universal de programas \c--.
Esta funci贸n, llamada 芦{\fgabrielen computar}禄, aparece en el ep茅ndice C.

Las funciones recursivas reciben como entrada y dan como resultado n煤meros naturales. Por tanto,
habr谩 que encontrar la manera de codificar los programas, es decir, encontrar una funci贸n {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificaci贸n
como un n煤mero natural de un programa $ \psi $; as铆, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda despu茅s de la ejecuci贸n, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver c贸mo es la funci贸n {\it C}; seguidamente se comentar谩 brevemente la funci贸n
芦{\fgabrielen computar}禄 y para finalizar la secci贸n veremos c贸mo obtener, a partir de 芦{\fgabrielen
computar}禄 y para un programa cualquier {\it P}, una funci贸n recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcular铆a {\it P} con esos datos.
\encabezados{Programas como n煤meros naturales}
Para ver c贸mo representar un programa \c-- como un n煤mero natural para que pueda ser usado por las
funciones recursivas dividiremos la explicaci贸n en dos partes: explicamos primero c贸mo se codifica
el contenido de una posici贸n y vali茅ndonos de esto definiremos despu茅s la funci贸n {\it C} que
buscamos.
\encabezadot{Codificaci贸n de contenido de posiciones}
Para un programa {\it p} en \c-- vamos a definir una funci贸n $ c_p $ sobre las posiciones de {\it p}
tal que dada una posici贸n devuelva la codificaci贸n como n煤mero natural de la instrucci贸n en esa
posici贸n. Definiremos primero una funci贸n $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f()= 0$, esto es, si no hay dato (contenido de una posici贸n vac铆a).

Para instrucciones que tienen un 煤nico s铆mbolo:
\espacioej$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3, $\hskip22pt $ f(\hbox{\fcode1})=4 $.

Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.0ex\hbox{}}, con \nnat:
\espacioej$ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.0ex\hbox{}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos sencillas funciones: una funci贸n $ g $ que dada una posici贸n de un programa
devuelve la instrucci贸n contenida en esa posici贸n, o nada si la posici贸n est谩 vac铆a; y una funci贸n
para un programa {\it p}, $ h_p $, tal que $ h_p(1) $ es la primera posici贸n de {\it p}, y, para
todo \nnat, $ h_p(n+1) $ es la siguiente de la posici贸n $ h_p(n) $ si tal posici贸n existe, y no est谩
definido si la posici贸n no existe. La funci贸n $ c_p $ ser谩 la composici贸n de estas tres funciones:
%% \espacioej $ c_p = f \circ g \circ  h_p$.
\encaje
$ c_p = f \circ g \circ  h_p$.
\finencaje
Poniendo como ejemplo un programa al que llamaremos {\it 唯}\/:
\vskip.23in
\hbox{{\textfont0=\fpies\textfont1=\tenipeq\scriptfont1=\sevenipeq\textfont2=\tensypeq\scriptfont2=\sevenypeq\parskip3pt
\hbox{\hskip.3in\programa{{\inst1{2}}{\inst1{3}}{\inst1{0}}{\inst\estrella1}}}
\hskip.25in\vbox{$ c_\psi(1)=12 $\par$ c_\psi(2)=16 $\par$ c_\psi(3)=4 $\par$ c_\psi(4)=7
$\vskip2pt}}}
\vskip10pt\vskip0in
\encabezadot{Codificaci贸n de programas}
Para llegar hasta la definici贸n de {\it C} que buscamos, antes definimos dos funciones: una funci贸n,
{\it pm}, para todo \nnat\ de la siguiente manera:
\listanormal
$ pm(1)=5 $\par
$ pm(n+1) $ \hskip3pt es el menor primo mayor que \hskip3pt $ pm(n) $
\finlista
y otra funci贸n sobre un programa {\it p}, a la que llamaremos {\it cm}, con el mismo dominio que la
funci贸n {\it c} definida anteriormente, del siguiente modo:
\listanormal
$ cm_p(1)=3^{c(1)} $\par
$ cm_p(n+1)=cm_p(n)\times pm(n)^{c(n+1)} $
\finlista
Definimos por fin la funci贸n {\it C} que buscamos, que da como resultado la codificaci贸n de un
programa {\it P}, como sigue:
\vskip18pt
\hbox{\hskip.48in{\fitems \raise7.4pt\hbox{$ C(P)=cm_p(\alpha) $} \hskip18pt\vbox{\noindent donde $ \alpha\ge n $
para todo $ n $\hskip0pt plus 1fil\break perteneciente al dominio de $ cm_p $.}}}
\vskip18pt
\noindent Llamemos 煤ltima posici贸n de un programa {\it P} a la posici贸n para la que no hay siguiente
posici贸n en {\it P}. Sea {\fmats } el conjunto de los programas tales que la 煤ltima posici贸n est谩
vac铆a y es la siguiente de alguna posici贸n. Es f谩cil ver que cualquier programa en {\fmats } se
puede transformar en uno equivalente a efectos de computaci贸n, est茅 o no en {\fmats }, quitando la
煤ltima posici贸n. Con los programas que no pertenecen a {\fmats } como dominio la funci贸n {\it C} es
biyectiva; por tanto, cualquier programa, o uno equivalente, se puede codificar y decodificar
un铆vocamente.

Vamos a ver un ejemplo de codificaci贸n de un programa. Para ello tomaremos el programa que se us贸 en
搂5 para explicar c贸mo se escribe en una m谩quina de Turing y lo usaremos para ver c贸mo se transforma
en un n煤mero natural que sirva como entrada para la func铆on recursiva del ap茅ndice D. As铆, si
llamamos {\fmats 尉} al programa
\vskip.23in
\hbox{\hskip.3in\programa{{\inst1{1}} = { } 0 1 {\inst\estrella4}}}
\vskip.2in
\noindent el n煤mero que lo representar铆a ser谩:
\encaje
$ C(\hbox{{\fmats 尉}})=3^8 \times 5^2 \times 7^0 \times 11^1 \times 13^4 \times 17^{19} $
\finencaje
La manera de descodificar un n煤mero para obtener el programa que representa se ve en el
funcionamiento de la funci贸n 芦{\fgabrielen computar}禄. Damos a continuaci贸n algunos apuntes sobre su
funcionamiento.

{\font\fgabrieleg="GabrieleBadAH" at 17pt
\encabezados{Apuntes sobre la funci贸n 芦{\fgabrieleg computar}禄}}%
La definici贸n de funci贸n recursiva que se usa aqu铆 est谩 basada en las definiciones de funciones
primitivas recursivas que se dan en [2], pag. 219, y en [x], cap铆tulo~6. Concretamente, la funci贸n
芦{\fgabrielen computar}禄 y las dem谩s funciones que usa son de uno de los siguientes tipos,
expresados con la notaci贸n en [2], donde $ y'=y+1 $\hskip8pt y\hskip8pt $ 1\le i\le n $:
\vskip2pt
\lfunciones
\funespec{$ \hbox{}\equis=0 $}
\funespec{$ \hbox{}(x)= x+1 $}
\funespec{$ \hbox{}\equis= x_i $}
\funespec{\vrule width0pt depth10pt$ \hbox{}\equis= \hbox{}(\hbox{}_1\equis, ... , \hbox{}_m\equis) $}
\funespec{$ \cases{\hbox{\vrule width0pt depth18pt\fmats }(0, x_2, ... x_n)=\hbox{\fmats }(x_2, ... ,x_n), \cr
                   \hbox{\fmats }(0, x_2, ... x_n)=\hbox{\fmats }(y, \hbox{\fmats }(0, x_2, ... x_n), (x_2, ... ,x_n))\cr}$}
\vskip4pt\vskip0pt\finlista
Las funciones se muestran en el ap茅ndice D como un programa \c-- escrito con macros, o sea, como un
programa \C/, con lo que es sencillo de entender. Las dos primeras funciones, llamadas 芦{\fgabrielen
cero}禄 son del tipo (i); la siguiente funci贸n que aparece, 芦{\fgabrielen S}禄, es del tipo (ii); las
funciones en las l铆neas xx--xx, con nombres de la forma 芦U{\it x\_y}禄 son del tipo (iii); todas las
dem谩s funciones son de los tipos (iv) o (v). Concretamente, 芦{\fgabrielen computar}禄 es del tipo
(iv).

Antes de seguir con el repaso de las funciones conviene introducir el concepto que llamaremos {\it
registro}, relacionado con los programas \c-- y que se maneja durante la computaci贸n tal y como se
hace en el ap茅ndice D.
\encabezadot{Se帽alador y registro}
Imaginemos que el ejecutor de un programa \c-- tiene otras cosas que hacer, y va y viene, alternando
la ejecuci贸n de algunas instrucciones del programa con sus otras tareas; o que el programa es muy
largo y hay varios ejecutores que van turn谩ndose en la ejecuci贸n del programa. Esto se podr铆a hacer
manteniendo un se帽alador que apunte a la pr贸xima instrucci贸n que ser谩 ejecutada, del mismo modo que
se usa un marcap谩ginas en un libro. Asi se podr谩 dejar y retomar la tarea de ejecutar el programa a
capricho. Al conjunto de programa y el se帽alador es a lo que llamamos {\it registro}.

Durante la computaci贸n con 芦{\fgabrielen computar}禄 se trabaja con la codificaci贸n de registros. Al
principio de la ejecuci贸n se obtiene un registro a partir de la codificaci贸n del programa, con el
se帽alador en la primera posici贸n; seg煤n se van ejecutando instrucciones se obtienen las
codificaciones con el se帽alador donde corresponda. La codificaci贸n de un registro  para un programa
{\it P} es como sigue:

Si {\it P} es un programa y $\hbox{}=\hbox{C}(P)$ es la codificaci贸n de {\it P} como n煤mero
natural, la codificaci贸n del registro  a partir de  es como sigue:
\listanormal
Si $\hbox{}=\hbox{C}(\hbox{{\it P}})$ \ es la codificaci贸n de {\it P}, entonces \ $ \hbox{}=2\times\hbox{} $ \
es la codificaci贸n del registro con el se帽alador apuntando a la primera posici贸n de {\it P}.

Si 渭 es la codificaci贸n de un registro con el se帽alizador  apuntando a la posici贸n , entonces
\ $ \hbox{}=2\times\hbox{渭} $ \ es la codificaci贸n del registro con el se帽alizador apuntando a la
siguiente posici贸n de  en {\it P}.
\finlista
\encabezadot{Apuntes II}
Continuamos haciendo un repaso a las funciones recursivas del ap茅ndice D.
