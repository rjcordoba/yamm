\encabezadop{Equivalencia de funciones recursivas y {\ccabez \c--}}%
Al igual que con las m√°quinas de Turing, la demostraci√≥n de la equivalencia de las funciones
recursivas consiste en presentar una funci√≥n que act√∫a como ejecutor universal de programas \c--.
Esta funci√≥n, llamada {\fgabrielen computar}, aparece en el ep√©ndice D.

Las funciones recursivas reciben como entrada y dan como resultado n√∫meros naturales. Por tanto,
habr√° que encontrar la manera de codificar los programas, es decir, encontrar una funci√≥n {\it C}
cuyo dominio sean los programas \c-- y tal que {\it C$ (\psi) $}\kernpeq\ sea la codificaci√≥n
como un n√∫mero natural de un programa $ \psi $; as√≠, si \kern.2em{\it P\/} es el programa
a ejecutar y \kern.2em{\it P'\/} el programa que queda despu√©s de la ejecuci√≥n, entonces \hbox{{\it
C}({\it P'}) = {\fgabrielen computar}(\kernpeq{\it C}({\it P})\kernpeq)}.

Vamos a ver c√≥mo es la funci√≥n {\it C}. Seguidamente se comentar√° brevemente la funci√≥n
{\fgabrielen computar} y para finalizar la secci√≥n veremos c√≥mo obtener, a partir de {\fgabrielen
computar} y para un programa cualquier {\it P}, una funci√≥n recursiva que recibiendo como argumento
unos datos de entrada calcule lo mismo que calcular√≠a {\it P} con esos datos.
\encabezados{Programas como n√∫meros naturales}%
Para ver c√≥mo representar un programa \c-- como un n√∫mero natural para que pueda ser usado por las
funciones recursivas dividiremos la explicaci√≥n en dos partes: explicamos primero c√≥mo se codifica
el contenido de una posici√≥n y va\-li√©n\-donos de esto definiremos despu√©s la funci√≥n {\it C} que
buscamos.
\encabezadot{Codificaci√≥n de contenido de posiciones}%
Para un programa {\it p} en \c-- vamos a definir una funci√≥n $ c_p $ sobre las posiciones de {\it p}
tal que dada una posici√≥n devuelva la codificaci√≥n como n√∫mero natural del contenido de esa
posici√≥n. Definiremos primero una funci√≥n $ f $, con las intrucciones de \c-- como dominio, del
siguiente modo:
\listanormal
$ f(\kernpeq)= 0$; esto es, si no hay dato (contenido de una posici√≥n vac√≠a).

Para instrucciones que tienen un √∫nico s√≠mbolo:
\espacioej$ f(\hbox{\fcode0})= 1$,\hskip22pt$ f(\hbox{\fcode=})=2 $,\hskip22pt $
f(\hbox{\fcode\estrella})=3, $\hskip22pt $ f(\hbox{\fcode1})=4 $.

Para instrucciones de la forma {\fgramatnoterm x\super{\fsupnoterm\kern.1em
n}\fcode\kern-.15em\lower.0ex\hbox{‚Äô}}, con \nnat:
\espacioej$ f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}%
\fcode\kern-.15em\lower.0ex\hbox{‚Äô}}}) =f(\hbox{{\fgramatnoterm x\super{\fsupnoterm\kern.1em n}}})+4 $.
\finlista
Por ejemplo, $ f(\hbox{{\fcode\inst{1}3}})=16 $ y $ f(\hbox{{\fcode\inst{=}2}})=10 $.

Definimos ahora dos sencillas funciones: una funci√≥n $ g $ que dada una posici√≥n de un programa
devuelve la instrucci√≥n contenida en esa posici√≥n, o nada si la posici√≥n est√° vac√≠a; y una funci√≥n
para un programa {\it p}, $ h_p $, tal que $ h_p(1) $ es la primera posici√≥n de {\it p}, y, para
todo \nnat, $ h_p(n+1) $ es la siguiente de la posici√≥n $ h_p(n) $ si tal posici√≥n existe, y no est√°
definido si la posici√≥n no existe. La funci√≥n $ c_p $ ser√° la composici√≥n de estas tres funciones:
%% \espacioej $ c_p = f \circ g \circ  h_p$.
\encaje
$ c_p = f \circ g \circ  h_p$.
\finencaje
Poniendo como ejemplo un programa al que llamaremos {\it Œ®}\/:
\vskip.23in
\hbox{{\textfont0=\fpies\textfont1=\tenipeq\scriptfont1=\sevenipeq\textfont2=\tensypeq\scriptfont2=\sevenypeq\parskip3pt
\hbox{\hskip.3in\programa{{\inst1{2}}{\inst1{3}}{\inst1{0}}{\inst\estrella1}}}
\hskip.25in\vbox{$ c_\psi(1)=12 $\par$ c_\psi(2)=16 $\par$ c_\psi(3)=4 $\par$ c_\psi(4)=7
$\vskip2pt}}}
\vskip10pt\vskip0in
\encabezadot{Codificaci√≥n de programas}
Para llegar hasta la definici√≥n de {\it C} que buscamos, antes definimos dos funciones: una funci√≥n,
{\it pm}, para todo \nnat\ de la siguiente manera:
\listanormal
$ pm(1)=5 $\par
$ pm(n+1) $ \hskip3pt es el menor primo mayor que \hskip3pt $ pm(n) $
\finlista
y otra funci√≥n sobre un programa {\it p}, a la que llamaremos {\it cm}, con el mismo dominio que la
funci√≥n {\it c} definida anteriormente, del siguiente modo:
\listanormal
$ cm_p(1)=3^{c(1)} $\par
$ cm_p(n+1)=cm_p(n)\times pm(n)^{c(n+1)} $
\finlista
Definimos por fin la funci√≥n {\it C} que buscamos, que da como resultado la codificaci√≥n de un
programa {\it P}, como sigue:
\vskip18pt
\hbox{\hskip.48in{\fitems \raise7.4pt\hbox{$ C(P)=cm_p(\alpha) $} \hskip18pt\vbox{\noindent donde $ \alpha\ge n $
para todo $ n $\hskip0pt plus 1fil\break perteneciente al dominio de $ cm_p $.}}}
\vskip18pt
\noindent Llamemos √∫ltima posici√≥n de un programa {\it P} a la posici√≥n para la que no hay siguiente
posici√≥n en {\it P}. Sea {\fmats ùïå} el conjunto de los programas tales que la √∫ltima posici√≥n est√°
vac√≠a y es la siguiente de alguna posici√≥n. Es f√°cil ver que cualquier programa en {\fmats ùïå} se
puede transformar en uno equivalente a efectos de computaci√≥n, est√© o no en {\fmats ùïå}, quitando la
√∫ltima posici√≥n. Con los programas que no pertenecen a {\fmats ùïå} como dominio, la funci√≥n {\it C} es
biyectiva; por tanto, cualquier programa, o uno equivalente, se puede codificar y decodificar
un√≠vocamente.

Vamos a ver un ejemplo de codificaci√≥n de un programa. Para ello tomaremos de nuevo el programa que
se us√≥ en ¬ß5 para explicar c√≥mo se escribe en una m√°quina de Turing y lo usaremos otra vez de
ejemplo para ver c√≥mo se transforma en un n√∫mero natural que sirva como entrada para la func√≠on
recursiva del ap√©ndice D. As√≠, si llamamos {\fmats Œæ} al programa
\vskip.23in
\hbox{\hskip.3in\programa{{\inst1{1}} = { } 0 1 {\inst\estrella4}}}
\vskip.2in
\noindent el n√∫mero que lo representar√≠a ser√°:
\encaje
$ C(\hbox{{\fmats Œæ}})=3^8 \times 5^2 \times 7^0 \times 11^1 \times 13^4 \times 17^{19} $
\finencaje
La manera de descodificar un n√∫mero para obtener el programa que representa se ve en el
funcionamiento de la funci√≥n {\fgabrielen computar}. Damos a continuaci√≥n algunos apuntes sobre su
funcionamiento.

\font\fgabrieleeg="GabrieleBadAH" at 17pt
\encabezados{Apuntes sobre la funci√≥n {\fgabrieleeg computar}}%
La definici√≥n de funci√≥n recursiva que se usa aqu√≠ est√° basada en las definiciones de funciones
primitivas recursivas que se dan en [2], pag. 219, y en [6], cap√≠tulo~6. Concretamente, la funci√≥n
{\fgabrielen computar} y las dem√°s funciones que se usan son de uno de los siguientes tipos,
expresados con la notaci√≥n en [2], donde $ y'=y+1 $\hskip8pt y\hskip8pt $ 1\le i\le n $:
\vskip2pt
\lfunciones
\funespec{$ \hbox{œÜ}\equis=0 $}
\funespec{$ \hbox{œÜ}(x)= x+1 $}
\funespec{$ \hbox{œÜ}\equis= x_i $}
\funespec{\vrule width0pt depth10pt$ \hbox{œÜ}\equis= \hbox{œà}(\hbox{œá}_1\equis, ... , \hbox{œá}_m\equis) $}
\funespec{$ \cases{\hbox{\vrule width0pt depth18pt\fmats œÜ}(0, x_2, ... x_n)=\hbox{œà}(x_2, ... ,x_n), \cr
                   \hbox{\fmats œÜ}(y', x_2, ... x_n)=\hbox{\fmats œá}(y, \hbox{\fmats œÜ}(y, x_2, ... x_n), x_2, ... ,x_n)\cr}$}
\vskip4pt\vskip0pt\finlista
Las dos primeras funciones en el ap√©ndice D, llamadas {\fgabrielen cero}, son del tipo (i); la
siguiente funci√≥n que aparece, {\fgabrielen S}, es del tipo (ii); las funciones entre las l√≠neas 20
y 82, con nombres de la forma ¬´U{\it x\_y}¬ª son del tipo (iii); todas las dem√°s funciones son de los
tipos (iv) o (v). Concretamente, {\fgabrielen computar} es del tipo (iv).

Las funciones anteriores y el resto se muestran como parte de un programa \c-- escrito con macros, o
sea, como si estuviera escrito en \C/, con lo que son senci\-llas de entender y no requieren mucha
explicaci√≥n. Veremos por encima algunas de las funciones y c√≥mo se hace la computaci√≥n. Pero antes
de seguir con el repaso de las funciones conviene introducir el concepto que llamaremos {\it
registro}, relacionado con los programas \c-- y que se maneja durante la computaci√≥n.
\encabezadot{Se√±alador y registro}%
Imaginemos que el ejecutor de un programa \c-- tiene otras cosas que hacer y va y viene, alternando
la ejecuci√≥n de algunas instrucciones del programa con sus otras tareas; o que el programa es muy
largo y hay varios ejecutores que van turn√°ndose en la ejecuci√≥n del programa. Esto se podr√≠a hacer
manteniendo un se√±alador que apunte a la pr√≥xima instrucci√≥n que ser√° ejecutada, del mismo modo que
se usa un marcap√°ginas en un libro. Asi se podr√° dejar y retomar la tarea de ejecutar el programa a
capricho. Al conjunto de programa y el se√±alador es a lo que llamamos {\it registro}.

Durante el c√°lculo con {\fgabrielen computar} se trabaja con la codificaci√≥n de registros. Al
principio de la ejecuci√≥n se obtiene un registro a partir de la codificaci√≥n del programa, con el
se√±alador en la primera posici√≥n; seg√∫n se van ejecutando ins\-trucciones se obtienen las
codificaciones con el se√±alador donde corresponda. Para un programa {\it P}, la codificaci√≥n de un
registro œÅ es como sigue:
%% Si {\it P} es un programa y $\hbox{œÖ}=\hbox{C}(P)$ es la codificaci√≥n de {\it P} como n√∫mero
%% natural, la codificaci√≥n del registro œÅ a partir de œÖ es como sigue:
\listanormal
Si $\hbox{œÖ}=\hbox{C}(\hbox{{\it P}})$ \ es la codificaci√≥n de {\it P}, entonces \ $ \hbox{œÅ}=2\times\hbox{œÖ} $ \
es la codificaci√≥n del registro con el se√±alador apuntando a la primera posici√≥n de {\it P}.

Si Œº es la codificaci√≥n de un registro con el se√±alizador apuntando a la posici√≥n œà, entonces \
$ \hbox{œÅ}=2\times\hbox{Œº} $ \ es la codificaci√≥n del registro con el se√±alizador apuntando a la
siguiente posici√≥n de œà en {\it P}.
\finlista
Una vez vistos estos conceptos y c√≥mo se codifican, vamos a ver c√≥mo se usan en las funciones
recursivas cuando ejecutan un programa \c--, siguiendo con el repaso del ap√©ndice D.
\encabezadot{Apuntes (continuaci√≥n)}%
Las funciones entre las l√≠neas 86 y 142 devuelven las constantes necesarias en otras funciones;
seguidamente hay funciones que realizan operaciones aritm√©ticas y relacionales, y basadas en ellas
otras funciones que resuelven problemas m√°s espec√≠ficos y que ser√°n necesarias para definir
funciones que aparecen m√°s adelante. Los comentarios que aparecen en el c√≥digo explican lo que
hacen.

La funci√≥n {\fgabrielen computar} recibe el programa y lo pasa junto con la constante 2 a la funci√≥n
{\fgabrielen computar\_aux}, para que √©sta multiplique, creando el registro con el se√±alador
apuntando a la primera posici√≥n. La funci√≥n {\fgabrielen evaluar} recibe el re\-gis\-tro junto con la
constante 1. Esta funci√≥n decide si parar la ejecuci√≥n o continuar. El par√°metro {\fgabrielen X1}
indica si la √∫ltima vez que se interpret√≥ una posici√≥n √©sta estaba vac√≠a o si hay que seguir con la
ejecuci√≥n del programa. Si se llama con 0 la ejecuci√≥n se detendr√≠a y se devolver√≠a el programa
ejecutado. {\fgabrielen computar\_aux} llama a {\fgabrielen evaluar} con argumento 1, ya que estamos
al principio de la evaluaci√≥n del programa, y esta √∫ltima llama a {\fgabrielen ejecutar}, que
interpretar√° la posici√≥n que indica el se√±alador.

Desde {\fgabrielen ejecutar}, a partir del registro se saca el contenido de la posici√≥n a la que
apunta el se√±alador y de √©ste la instrucci√≥n, si la hubiera. La funci√≥n {\fgabrielen eval\_registro}
intenta ejecutar los 4 tipos de instrucciones o nada si la posici√≥n a interpretar est√° vac√≠a. Cada
una de las funciones que empieza por {\fgabrielen eval\_} recibe como primer par√°metro el tipo de
instrucci√≥n qeu hay que ejecutar o si la posici√≥n est√° vac√≠a; cada una de las funciones modificar√° y
devolver√° el registro seg√∫n reciba el tipo de instrucci√≥n que puede ejecutar o devolver√° 0 en caso
contrario. Por ejemplo, si el primer par√°metro con el que se llama a la funci√≥n {\fgabrielen
eval\_marcar} indica que la intrucci√≥n a ejecutar es {\it marcar}, pondr√° una marca en la posici√≥n
referida por la instrucci√≥n, avanzar√° el se√±alador una posici√≥n y devolver√° el registro as√≠
modificado; si la instrucci√≥n es otra, devolver√° 0 en vez del registro. La funci√≥n {\fgabrielen
eval\_registro} devuelve finalmente la suma de todos los resultados; s√≥lo uno ser√° distinto de 0,
con lo que √©ste ser√° el resultado global. La funci√≥n {\fgabrielen ejec3} recibe este valor y llama a
{\fgabrielen hay\_inst} para comprobar si la posici√≥n estaba vac√≠a, guardando este valor en
{\fgabrielen V1}, que ser√° 0 o 1; con este valor y el registro despu√©s de interpretar la posici√≥n
adecuada, vuelve a empezar el ciclo llamando a {\fgabrielen evaluar}.

Casi todas las dem√°s funciones tienen que ver con el descodificado y codificado de intrucci√≥n,
posiciones, se√±alador..., y con la ejecuci√≥n de las distintas instrucciones. Es m√°s f√°cil seguirlo
con el c√≥digo y los comentarios que con una explicaci√≥n.

\encabezados{Sin programa, solamente datos de entrada}%
Vamos a ver c√≥mo construir una funci√≥n que reciba los datos de entrada que recibir√≠a un programa
{\it P} en \c-- y devuelva lo mismo que devolver√≠a la funci√≥n {\fgabrielen computar} cuando tiene
como entrada el programa {\it P} con esos datos. Esta funci√≥n lo √∫nico que tendr√° que hacer es
‚Äòpreparar‚Äô un programa a partir de los datos de entrada y de {\it P} y pasarlo como argumento a
{\fgabrielen computar} para que lo ejecute. Al igual que se hizo en la explicaci√≥n para las m√°quinas
de Turing, vamos a suponer que los datos de entrada para {\it P} se colocar√≠an en las primeras
posiciones co\-rres\-pondientes a las variables o que se modifica {\it P} para que sea as√≠. Para que la
explicaci√≥n sea m√°s corta supondremos tambi√©n que el programa {\it P} recibe solamente un dato de
entrada. El caso para m√°s de un dato de entrada es algo m√°s largo pero el proceso es casi igual.

Para que la funci√≥n que buscamos, a la que llamaremos {\fgabrielen precomputar}, ejecute un
programa a partir de los datos de entrada, este programa tiene que ser conocido al construir la
funci√≥n, y por tanto ser√°n conocidos tambi√©n su codificaci√≥n y el mayor n√∫mero primo que se ha
usado para la codificaci√≥n; sean √©stos {\it n} y {\it p} respectivamente. La funci√≥n ser√≠a:

\font\fgabrielen="GabrieleBadAH" at 11pt
\cachosrec
function precomputar(var X1)\Uchar123
~~~var V1 = preparar(X1);
~~~return computar(V1);
\Uchar125
\fincachos
La funci√≥n preparar usar√° el dato de entrada y la codificaci√≥n {\it n}, que es una cons\-tan\-te, para
devolver la codificaci√≥n del programa que necesitamos. La funci√≥n ser√°:
\cachosrec
function preparar(var X1)\Uchar123
~~~var V1 = programa(X1);
~~~var V2 = entrada(X1);
~~~return mult(V1, V2);
\Uchar125
\fincachos
La funci√≥n {\fgabrielen programa} usar√° {\fgabrielen cero} y luego {\fgabrielen S} las veces que
haga falta para devolver la constante {\it n}. La funci√≥n {\fgabrielen entrada} devolver√° $ p^\theta
$, donde {\it Œ∏\/} es la codificaci√≥n del contenido de lo que ser√≠a la posici√≥n siguiente a la
√∫ltima posici√≥n del programa {\it P} con el dato de entrada en ella. Con la multiplicaci√≥n que se
lleva a cabo en {\fgabrielen mult} se obtiene la codificaci√≥n del programa que queremos. La funci√≥n
{\fgabrielen entrada} ser√≠a de la siguiente manera:
\cachosrec
function entrada(var X1)\Uchar123
~~~var V1 = cod\_instrucci√≥n(X1);
~~~var V2 = primo(X1);
~~~var V3 = uno(X1);
~~~return mult\_veces(V1, V2, V3);
\Uchar125
\fincachos
La funci√≥n {\fgabrielen primo} devolver√° como constante el n√∫mero primo {\it p} mencionado
anteriormente, de manera an√°loga a se hace en {\fgabrielen programa}. {\fgabrielen
cod\_instrucci√≥n} devuelve el {\it Œ∏\/} visto antes, que ser√° igual que la codificaci√≥n del
contenido de una posici√≥n con una instrucci√≥n {\it marcar} con la posici√≥n referida igual al dato
de entrada. Las funciones {\fgabrielen uno} y {\fgabrielen mult\_veces} aparecen en el ap√©ndice
D.  La funci√≥n {\fgabrielen cod\_instrucci√≥n} ser√≠a:
\cachosrec
function cod\_instrucci√≥n(var X1)\Uchar123
~~~var V1 = cuatro(X1);
~~~var V2 = U1\_1(X1);
~~~return mult(V1, V2);
\Uchar125
\fincachos
Las funciones {\fgabrielen U1\_1} y {\fgabrielen mult} aparecen en el ap√©ndice D. La funci√≥n
{\fgabrielen cuatro} con un s√≥lo par√°metro no aparece pero a partir de las que aparecen es f√°cil
ver c√≥mo construirla para que devuelva la constante 4.

