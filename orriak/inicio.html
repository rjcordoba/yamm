<p>Las secciones del sitio son las siguientes:</p>
<h3>C--</h3>
<h4>Lenguaje</h4>
<p>
  Especificación del lenguaje de programación C--. Una lista ordenada de instrucciones del lenguaje forman un <em>programa</em>.
  Para ejecutar el programa la instrucción inicial se coloca en la <em>primera posición</em> y el resto de instrucciones en
  posiciones sucesivas. Cuando en una posición no hay nada o algo que no sea una instrucción tal y como se definen en la
  especificación, diremos que en la posición hay una <em>instrucción nula</em>.		  
</p>
<p>
  Durante la ejecución del programa se mantiene un indicador que señala la próxima instrucción en ser ejecutada; a este
  indicador le llamaré <em>puntero</em>. Al conjunsto de programa y puntero le llamaré <em>registro</em>.
</p>
<p>
  Las instrucciones especifican cómo hay que modificar el registro. Cada ejecución de una instrucción diré que es un
  <em>paso</em> en la ejecución del programa.
</p>
<p>
  Cada instrucción hace referencia a una posición del programa, que influye en el resultado de la ejecución. A esta
  posición le llamaré la <em>posición referida</em> por la instrucción.
</p>
<p>
  Al ente qeu ejecuta el programa C-- lo llamaré <em>computador</em>.
</p>
<h4>Macros</h4>
<p>
  Se presentan una serie de macroinstrucciones, cadenas de símbolos que pueden ser sustituidos sistemáticamente por otras cadenas.
  Al ente que realiza esta sustitución de símbolos le llamaré <em>expansor</em> o <em>traductor</em>. Se presentan además algunas
  reglas que debe seguir el traductor a la hora de hacer el conjunto de sustituciones.
</p>
<p>
  Algunos de los recursos usados en la explicación son:
</p>
<ul class="lista_rec">
  <li>
	<h5 id="postulados"><span>postulados</span></h5>
	<p>
	  Explicación de algunas normas que sigue el traductor al transformar algunas cadenas.
	</p>
  </li>
  <li>
	<h5 id="ejemplos">ejemplos</h5>
	<p>
	  Muestran secuencias de expansiones de macros explicadas con anterioridad.
	</p>
  </li>
  <li>
	<h5 id="macros">macros</h5>
	<p>
	  Se muestran en la forma: <i>cadena1</i> <span class="flecha">⮕</span> <i>cadena2</i>, donde <i>cadena1</i> es una cadena de símbolos
	  que reconoce el traductor y <i>cadena2</i> son los símbolos en los que la transforma. Las sustituciones de macros se hacen, según se
	  encuentran en el texto, de izquiera a derecha y de arriba hacia abajo.
	</p>
  </li>
  <li>
	<h5 id="reglas">reglas gramaticales</h5>
	<p>
	  Usadas para definir términos que se usarán con posterioridad.
	</p>
  </li>
  <li>
	<h5 id="traductor">sobre traductor</h5>
	<p>
	  Definición de términos y reglas que usará el traductor para conseguir un programa C-- a partir de
	  macroinstrucciones..
	</p>
  </li>
</ul>
<h4>Ejemplo Turing</h4>
<p>
  Se muestra un programa en C-- (usando macros) que ejecuta una máquina de Turing introducida como dato. Con este ejemplo se pretende
  demostrar que se puede imitar la computación de cualquier máquina, siendo este programa en efecto una máquina universal de Turing
  escrita en C--.
</p>
<h4>Ejemplo recursivo</h4>
<p>
  Se muestra un programa en C-- (usando macros), que usa una función recursiva primitiva que computa lo mismo que un programa C-- que
  se recibe como argumento. La función actúa pues, extrapolando la terminología de Turing, como un ejecutor universal de programas C--.
  El programa está escrito basándome en las definiciones de S. C. Kleene (‘<span class="oblicuo">Introduction to Metamathematics</span>’,
  pág. 219).
</p>
<p>
  El programa C-- que recibe la función debe ser codificado como un entero no negativo. El programa recursivo transforma este código en
  otro código representando un registro del programa y el puntero que señala las instrucciones que se van ejecutando. La codificación se
  hace como sigue.
</p>
<h5 class="hrecur">codificación de instrucción</h5>
<p>
  Usando la notación <i>x</i><span class="codinst"></span><i>n</i>, donde <i>x</i> es una instrucción y <i>n</i> su código:
</p>
<ol class="lrecsv">
  <li>
	<p>La instrucción nula se codifica como 0.</p>
  </li>
  <li>
	<p>‘0’<span class="codinst"></span>1; ‘=’<span class="codinst"></span>2;
	  ‘＊’<span class="codinst"></span>3; ‘1’<span class="codinst"></span>4.
	</p>
  </li>
  <li>
	<p>Sea <i>x</i><span class="codinst"></span><i>n</i>; entonces <i>x</i>’<span class="codinst"></span><i>m</i>, donde <i>m</i> = <i>n</i> + 4.</p>
  </li>
</ol>
<h5 class="hrecur">codificación de programa</h5>
<p>
  Usando la notación <i>p</i><span class="codprog"></span><i>n</i>, donde <i>p</i> es un programa y <i>n</i> su código:
</p>
<ol class="lrecsv">
  <li>
	<p>
	  El programa sin instrucciones se codifica como 0.		
	</p>
  </li>
  <li>
	<p>
	  Sea <i>p</i> un programa, <i>x</i> su única instrucción y <i>x</i><span class="codinst"></span><i>n</i>;
	  entonces <i>p</i><span class="codprog"></span>3<sup><i>n</i></sup>.		
	</p>
  </li>
  <li>
	<p>
	  Sea <i>p</i><span class="codprog"></span><i>n</i>, <i>x</i><span class="codinst"></span><i>m</i>, <i>s</i> una posición
	  vacía en <i>p</i> y <i>q</i> el programa resultante de añadir a <i>p</i> la instrucción <i>x</i> en la posición <i>s</i>;
	  entonces <i>q</i><span class="codprog"></span><i>n</i> × α<sup><i>m</i></sup>, donde α es un número primo y <i>s</i>
	  el número de primos menores que α.
	</p>
  </li>
</ol>
<h5 class="hrecur">codificación de registro</h5>
<p>
  Sea <i>p</i><span class="codprog"></span><i>n</i>; el registro formado por el programa <i>p</i> y el puntero que señala a la posición <i>s</i>
  será <i>m</i>, donde <i>m</i> = <i>n</i> × 2<sup><i>s</i></sup>.
</p>
<aside class="ejemplo">
  <p>
	Por ejemplo, si el programa es la lista de instrucciones I<sub>1</sub>, I<sub>2</sub>, I<sub>3</sub>, I<sub>4</sub>, I<sub>5</sub>
	y los respectivos códigos códigos de las instrucciones son <i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>e</i>, la codificación del
	programa será:
  </p>
  <p class="ejemp_cod">
	3<sup><i>a</i></sup> × 5<sup><i>b</i></sup> × 7<sup><i>c</i></sup> × 11<sup><i>d</i></sup> × 13<sup><i>e</i></sup>
  </p>
  <p>La codificación del registro con el puntero señando a la primera posición será:</p>
  <p class="ejemp_cod">
	2 × 3<sup><i>a</i></sup> × 5<sup><i>b</i></sup> × 7<sup><i>c</i></sup> × 11<sup><i>d</i></sup> × 13<sup><i>e</i></sup>
  </p>
</aside>
<h3>AMT</h3>
<h4>Lenguaje</h4>
<p>
  Se presenta el lenguaje AMT (Alan Mathison Turing) para escribir máquinas de Turing. Este lenguaje es el definido por el propio Turing
  (‘<span class="oblicuo">On Computable Numbers, with an Application to the Entscheidungsproblem</span>’), salvo alguna pequeña modificación
  para evitar ambigüedades a la hora de interpretarlo.
</p>
<h4>Ejemplo C--</h4>
<p>
  Se presenta una máquina de Turing que ejecuta programas C--. La máquina empieza con el programa escrito en la cinta y el lector posicionado
  en, o a la derecha de, la celda más a la izquierda que no esté vacía. El programa C-- se escribe en la cinta de la siguiente manera:
</p>
<h5 class="hrecur">escritura del programa</h5>
<p>
  Al inicio todas las celdas están vacías. En el proceso de escribir el programa en la cinta, si no están todas las celdas vacías, sea en
  cualquier momento &alpha; la celda más a la derecha con algún símbolo, y sea &beta; la celda inmediatamente a la derecha de &alpha;.
</p>
<ol class="regt">
  <li>
	<p>
	  Si el programa sólo tiene una instrucción se escoge cualquier celda; sea ésta ℂ. Diré que la instrucción, sea ésta <span class="oblicuo">inst</span>,
	  se escribe a partir de ℂ si se hace de la siguiente manera:
	</p>
	<ol class="lrecsv">
	  <li>
		<p>
		  si la instrucción es nula se escribe en ℂ el símbolo ‘’’ (comilla).
		</p>
	  </li>
	  <li>
		<p>
		  si la instrucción <span class="oblicuo">inst</span> tiene un sólo símbolo se escribe éste en ℂ.
		</p>
	  </li>
	  <li>
		<p>
		  para escribir la instrucción <span class="oblicuo">inst</span><span class="comilla">’</span> se escribe <span class="oblicuo">inst</span> a partir de ℂ y el símbolo
		  ‘’’ en &beta;.
		</p>
	  </li>
	</ol>
  </li>
  <li>
	<p>
	  Si es programa tiene más de una instrucción, sea <span class="oblicuo">P</span> el programa, <span class="oblicuo">inst</span> la última
	  instrucción y <span class="oblicuo">P</span><span class="comilla">’</span> el programa resultante de quitar <span class="oblicuo">inst</span> a <span class="oblicuo">P</span>.
	  Para escribir <span class="oblicuo">P</span>:
	</p>
	<ol class="lrecsv">
	  <li>
		<p>se escribe <span class="oblicuo">P</span><span class="comilla">’</span>.</p>
	  </li>
	  <li>
		<p>se escribe <span class="oblicuo">inst</span> a partir de &beta;.</p>
	  </li>
	</ol>
  </li>
</ol>
<p>
  Los sucesivos registros que se derivarían al ejecutar al programa por un computador de C-- quedan reflejados, en el mismo orden, por algún
  estado de la máquina. Si la ejecución del programa C-- terminase en caso de ser ejecutado por un computador la máquina pararía, e inviertiendo
  las reglas sobre escritura en la cinta se podría obtener el programa final resultante de la ejecución. Esta máquina es por tanto un computador
  de C--.
</p>
<aside class="ejemplo">
  <p>
	Por ejemplo, si el programa es:
  </p>
  <ol id="ejt">
	<li>0</li>
	<li>=<span class="comil"><span>’</span><span>’</span></span></li>
	<li>&nbsp;</li>
	<li>1</li>
	<li>1<span class="comil"><span>’</span><span>’</span></span></li>
	<li>＊<span class="comil"><span>’</span><span>’</span><span>’</span><span>’</span></span></li>
  </ol>
  <p>
	Habrá que escribir en la cinta:
  </p>
  <ol id="cinta">
	<li>0</li>
	<li>=</li>
	<li>’</li>
	<li>’</li>
	<li>-</li>
	<li>1</li>
	<li>1</li>
	<li>’</li>
	<li>’</li>
	<li class="astrsk"><span>＊</span></li>
	<li>’</li>
	<li>’</li>
	<li>’</li>
	<li>’</li>
  </ol>
</aside>

